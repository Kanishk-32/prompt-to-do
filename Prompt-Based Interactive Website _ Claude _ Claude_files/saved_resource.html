<!DOCTYPE html>
<!-- saved from url=(0012)about:srcdoc -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.13/html-to-image.min.js" integrity="sha512-iZ2ORl595Wx6miw+GuadDet4WQbdSWS3JLMoNfY8cRGoEFy6oT3G9IbcrBeL6AfkgpA51ETt/faX6yLV+/gFJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      (function() {
        const originalConsole = window.console;
        window.console = {
          log: (...args) => {
            originalConsole.log(...args);
            window.parent.postMessage({ type: 'console', message: args.join(' ') }, '*');
          },
          error: (...args) => {
            originalConsole.error(...args);
            window.parent.postMessage({ type: 'console', message: 'Error: ' + args.join(' ') }, '*');
          },
          warn: (...args) => {
            originalConsole.warn(...args);
            window.parent.postMessage({ type: 'console', message: 'Warning: ' + args.join(' ') }, '*');
          }
        };

        let requestId = 0;
        let callbacksMap = new Map();
        let streamControllers = new Map();
        
        window.claude = {
          complete: (prompt) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'claudeComplete', id, prompt }, '*');
            });
          }
        };

        window.storage = {
          get: (key, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageGet', id, key, shared }, '*');
            });
          },
          set: (key, value, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageSet', id, key, value, shared }, '*');
            });
          },
          delete: (key, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageDelete', id, key, shared }, '*');
            });
          },
          list: (prefix, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageList', id, prefix, shared }, '*');
            });
          }
        };

        let pendingBlobs = new Map();
        URL.createObjectURL = (blob) => {
          // Store the blob and create an ID and URL for it
          const blobId = `blob-${Date.now()}-${Math.random()}`;
          pendingBlobs.set(blobId, blob);
          return `blob-request://${blobId}`;
        };

        URL.revokeObjectURL = (url) => {
          // Remove the blob from our store
          const blobId = url.replace("blob-request://", "");
          pendingBlobs.delete(blobId);
        };

        const getBlobFromURL = (url) => {
          const blobId = url.replace("blob-request://", "");
          return pendingBlobs.get(blobId);
        };

        // Override global fetch with streaming support
        window.fetch = (url, init = {}) => {
          return new Promise((resolve, reject) => {
            const id = requestId++;
            const channelId = `fetch-${id}-${Date.now()}`;
            
            callbacksMap.set(id, { 
              resolve: (response) => {
                // Create a ReadableStream for the response body
                const stream = new ReadableStream({
                  start(controller) {
                    streamControllers.set(channelId, controller);
                  },
                  cancel() {
                    streamControllers.delete(channelId);
                  }
                });
                
                // Create and return the Response with the stream
                resolve(new Response(stream, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                }));
              },
              reject,
              channelId
            });
            
            window.parent.postMessage({
              type: 'proxyFetch',
              id,
              url,
              init,
              channelId
            }, '*');
          });
        };

        window.addEventListener('message', async (event) => {
          if (event.data.type === 'takeScreenshot') {
            const rootElement = document.getElementById('artifacts-component-root-html');
            if (!rootElement) {
              window.parent.postMessage({
                type: 'screenshotError',
                error: new Error('Root element not found'),
              }, '*');
            }
            const screenshot = await htmlToImage.toPng(rootElement, {
              imagePlaceholder:
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdjePDgwX8ACOQDoNsk0PMAAAAASUVORK5CYII=",
            });
            window.parent.postMessage({
              type: 'screenshotData',
              data: screenshot,
            }, '*');
          } else if (event.data.type === 'claudeComplete') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.completion);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'proxyFetchResponse') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
              callbacksMap.delete(event.data.id);
            } else {
              // Initial response with headers, status, etc.
              callback.resolve({
                status: event.data.status,
                statusText: event.data.statusText,
                headers: event.data.headers
              });
              // Don't delete the callback yet if streaming
              if (!event.data.body) {
                callbacksMap.delete(event.data.id);
              }
            }
          } else if (event.data.type === 'proxyFetchStream') {
            // Handle streaming data chunks
            const controller = streamControllers.get(event.data.channelId);
            if (controller) {
              if (event.data.error) {
                controller.error(new Error(event.data.error));
                streamControllers.delete(event.data.channelId);
              } else if (event.data.done) {
                controller.close();
                streamControllers.delete(event.data.channelId);
                // Clean up the callback
                const callback = Array.from(callbacksMap.entries()).find(
                  ([_, value]) => value.channelId === event.data.channelId
                );
                if (callback) {
                  callbacksMap.delete(callback[0]);
                }
              } else if (event.data.chunk) {
                controller.enqueue(new Uint8Array(event.data.chunk));
              }
            }
          } else if (event.data.type === 'storageGet') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageSet') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageDelete') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageList') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          }
        });

        window.addEventListener('click', (event) => {
          const isEl = event.target instanceof HTMLElement;
          if (!isEl) return;
    
          // find ancestor links
          const linkEl = event.target.closest("a");
          if (!linkEl || !linkEl.href) return;
    
          event.preventDefault();
          event.stopImmediatePropagation();
    
          if (linkEl.href.startsWith("blob-request:")) {
            const blob = getBlobFromURL(linkEl.href);
            if (!blob) return;
            void blob.arrayBuffer().then((data) => {
              window.parent.postMessage({
                type: "downloadFile",
                filename: linkEl.download,
                data,
                mimeType: blob.type || "application/octet-stream",
              });
            });
          } else if (linkEl.href.startsWith("data:")) {
            const [header, base64Data] = linkEl.href.split(",");
            const mimeMatch = header.match(/data:([^;]+)/);
            const mimeType = mimeMatch ? mimeMatch[1] : "application/octet-stream";
            const binaryString = atob(base64Data);
            const data = Uint8Array.from(binaryString, (c) =>
              c.charCodeAt(0),
            ).buffer;
            window.parent.postMessage({
              type: "downloadFile",
              filename: linkEl.download,
              data,
              mimeType,
            });
          } else {
            let linkUrl;
            try {
              linkUrl = new URL(linkEl.href);
            } catch (error) {
              return;
            }
    
            if (linkUrl.hostname === window.location.hostname) return;
      
            window.parent.postMessage({
              type: 'openExternal',
              href: linkEl.href,
            }, '*');
          }
      });

        const originalOpen = window.open;
        window.open = function (url) {
          window.parent.postMessage({
            type: "openExternal",
            href: url,
          }, "*");
        };

        window.addEventListener('error', (event) => {
          window.parent.postMessage({ type: 'console', message: 'Uncaught Error: ' + event.message }, '*');
        });
      })();
    </script>
  
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Prompt-Based Website</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: all 0.5s ease;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .prompt-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .prompt-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid transparent;
            border-radius: 50px;
            background: rgba(255, 255, 255, 0.9);
            outline: none;
            margin-bottom: 15px;
        }

        .prompt-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .execute-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .execute-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .content-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            color: white;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .content-card h3 {
            margin-bottom: 15px;
            color: #f0f0f0;
        }

        .response-message {
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-style: italic;
        }

        .suggestion {
            background: rgba(255, 255, 0, 0.2);
            border-left: 4px solid #ffeb3b;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            border-left: 4px solid #f44336;
        }

        .success {
            background: rgba(0, 255, 0, 0.2);
            border-left: 4px solid #4caf50;
        }

        /* Animations */
        .floating {
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .spin {
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .dance {
            animation: dance 1s ease-in-out infinite;
        }

        @keyframes dance {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            25% { transform: translateX(-10px) rotate(-5deg); }
            50% { transform: translateX(0) rotate(0deg); }
            75% { transform: translateX(10px) rotate(5deg); }
        }

        .bounce {
            animation: bounce 1s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .wobble {
            animation: wobble 1s ease-in-out infinite;
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(0deg); }
            15% { transform: rotate(-5deg); }
            30% { transform: rotate(5deg); }
            45% { transform: rotate(-3deg); }
            60% { transform: rotate(3deg); }
            75% { transform: rotate(-1deg); }
        }

        .glitch {
            animation: glitch 2s linear infinite;
        }

        @keyframes glitch {
            0%, 100% { 
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
            10% { 
                transform: translate(-2px, -2px);
                filter: hue-rotate(90deg);
            }
            20% { 
                transform: translate(2px, 2px);
                filter: hue-rotate(180deg);
            }
        }

        /* Themes */
        .rainbow {
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8f00ff) !important;
            background-size: 400% 400% !important;
            animation: rainbow 3s ease infinite;
        }

        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .fire-mode {
            background: linear-gradient(45deg, #ff4757, #ff6b35, #ff9f43, #ffc048) !important;
            background-size: 400% 400% !important;
            animation: fireFlicker 1s ease-in-out infinite alternate;
        }

        @keyframes fireFlicker {
            0% { background-position: 0% 50%; filter: brightness(1); }
            100% { background-position: 100% 50%; filter: brightness(1.2); }
        }

        .ocean-mode {
            background: linear-gradient(45deg, #0077be, #00a8cc, #0abde3, #48cae4) !important;
            background-size: 400% 400% !important;
            animation: oceanWave 3s ease-in-out infinite;
        }

        @keyframes oceanWave {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .space-mode {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f3460 100%) !important;
        }

        .night-mode {
            background: linear-gradient(135deg, #0c0c0c 0%, #434343 100%) !important;
        }

        .red-theme {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%) !important;
        }

        .blue-theme {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%) !important;
        }

        .green-theme {
            background: linear-gradient(135deg, #00b894 0%, #00a085 100%) !important;
        }

        .yellow-theme {
            background: linear-gradient(135deg, #fdcb6e 0%, #f39c12 100%) !important;
        }

        .purple-theme {
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%) !important;
        }

        .pink-theme {
            background: linear-gradient(135deg, #fd79a8 0%, #e84393 100%) !important;
        }

        /* Effects */
        .neon-glow {
            box-shadow: 
                0 0 5px currentColor,
                0 0 10px currentColor,
                0 0 15px currentColor,
                0 0 20px currentColor !important;
            text-shadow: 0 0 10px currentColor !important;
        }

        .giant {
            transform: scale(1.5) !important;
        }

        .tiny {
            transform: scale(0.5) !important;
        }

        .blur-effect {
            filter: blur(5px);
        }

        .hidden {
            opacity: 0 !important;
        }

        /* Particles */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s linear forwards;
            z-index: 1000;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .hearts {
            position: absolute;
            color: #ff69b4;
            font-size: 25px;
            animation: heartfall 4s linear forwards;
            z-index: 1000;
        }

        @keyframes heartfall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .fade-in {
            animation: fadeIn 1s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
<script bis_use="true" type="text/javascript" charset="utf-8" data-bis-config="[&quot;facebook.com/&quot;,&quot;twitter.com/&quot;,&quot;youtube-nocookie.com/embed/&quot;,&quot;//vk.com/&quot;,&quot;//www.vk.com/&quot;,&quot;linkedin.com/&quot;,&quot;//www.linkedin.com/&quot;,&quot;//instagram.com/&quot;,&quot;//www.instagram.com/&quot;,&quot;//www.google.com/recaptcha/api2/&quot;,&quot;//hangouts.google.com/webchat/&quot;,&quot;//www.google.com/calendar/&quot;,&quot;//www.google.com/maps/embed&quot;,&quot;spotify.com/&quot;,&quot;soundcloud.com/&quot;,&quot;//player.vimeo.com/&quot;,&quot;//disqus.com/&quot;,&quot;//tgwidget.com/&quot;,&quot;//js.driftt.com/&quot;,&quot;friends2follow.com&quot;,&quot;/widget&quot;,&quot;login&quot;,&quot;//video.bigmir.net/&quot;,&quot;blogger.com&quot;,&quot;//smartlock.google.com/&quot;,&quot;//keep.google.com/&quot;,&quot;/web.tolstoycomments.com/&quot;,&quot;moz-extension://&quot;,&quot;chrome-extension://&quot;,&quot;/auth/&quot;,&quot;//analytics.google.com/&quot;,&quot;adclarity.com&quot;,&quot;paddle.com/checkout&quot;,&quot;hcaptcha.com&quot;,&quot;recaptcha.net&quot;,&quot;2captcha.com&quot;,&quot;accounts.google.com&quot;,&quot;www.google.com/shopping/customerreviews&quot;,&quot;buy.tinypass.com&quot;,&quot;gstatic.com&quot;,&quot;secureir.ebaystatic.com&quot;,&quot;docs.google.com&quot;,&quot;contacts.google.com&quot;,&quot;github.com&quot;,&quot;mail.google.com&quot;,&quot;chat.google.com&quot;,&quot;audio.xpleer.com&quot;,&quot;keepa.com&quot;,&quot;static.xx.fbcdn.net&quot;,&quot;sas.selleramp.com&quot;,&quot;1plus1.video&quot;,&quot;console.googletagservices.com&quot;,&quot;//lnkd.demdex.net/&quot;,&quot;//radar.cedexis.com/&quot;,&quot;//li.protechts.net/&quot;,&quot;challenges.cloudflare.com/&quot;,&quot;ogs.google.com&quot;]" src="chrome-extension://eppiocemhmnlbhjplcgkofciiegomcon/executors/traffic.js"></script></head>
<body id="artifacts-component-root-html" bis_status="ok" bis_frame_id="85" class="rainbow-theme">
    <div class="container">
        <div class="header">
            <h1>🤖 Smart Prompt Website</h1>
            <p>Type ANYTHING and watch the magic happen! I understand typos, emotions, colors, and more!</p>
        </div>

        <div class="prompt-section">
            <input type="text" class="prompt-input" placeholder="Type anything: &#39;helo&#39;, &#39;make it rad&#39;, &#39;I&#39;m happy&#39;, &#39;turn blu&#39;, &#39;big&#39;..." id="promptInput">
            <button class="execute-btn" onclick="executePrompt()">✨ Try It!</button>
            <div class="response-message suggestion" id="responseMessage" style="display: block;">🎲 I don't recognize "hi]" but it sounds interesting! Here's something creative!</div>
        </div>

        <div class="content-grid" id="contentGrid">
            <div class="content-card bounce">
                <h3>🧠 Smart Understanding</h3>
                <p>I understand typos, emotions, colors, sizes, and creative commands. Try misspelled words - I'll figure out what you mean!</p>
            </div>
            <div class="content-card bounce">
                <h3>🎨 Endless Possibilities</h3>
                <p>Express feelings like "happy", "sad", "excited". Use colors like "red", "blue", "rainbow". Try actions like "spin", "dance", "float".</p>
            </div>
            <div class="content-card bounce">
                <h3>✨ Creative Responses</h3>
                <p>Every input creates something unique. From simple words to complex emotions - I'll always find a way to respond visually!</p>
            </div>
            <div class="content-card bounce">
                <h3>🔧 Auto-Correction</h3>
                <p>Don't worry about spelling! Type "blu" for blue, "grav" for gravity, "danc" for dance. I'll understand and suggest corrections.</p>
            </div>
        </div>
    </div>

    <script>
        // Smart command matching system
        function executePrompt() {
            const input = document.getElementById('promptInput');
            const prompt = input.value.trim().toLowerCase();
            
            if (!prompt) {
                showResponse("🤔 Try typing something! I'm ready to understand anything you say!", 'suggestion');
                return;
            }

            // Process the prompt intelligently
            processIntelligentPrompt(prompt);
            input.value = '';
        }

        function processIntelligentPrompt(prompt) {
            let applied = false;
            let corrections = [];

            // Color detection with typo handling
            if (matchesWord(prompt, ['red', 'rad', 'reed'])) {
                applyColorTheme('red');
                if (prompt.includes('rad') || prompt.includes('reed')) {
                    corrections.push('red');
                }
                applied = true;
            }
            else if (matchesWord(prompt, ['blue', 'blu', 'blew', 'bleu'])) {
                applyColorTheme('blue');
                if (!prompt.includes('blue')) corrections.push('blue');
                applied = true;
            }
            else if (matchesWord(prompt, ['green', 'gren', 'grean', 'grn'])) {
                applyColorTheme('green');
                if (!prompt.includes('green')) corrections.push('green');
                applied = true;
            }
            else if (matchesWord(prompt, ['yellow', 'yelow', 'yello', 'ylw'])) {
                applyColorTheme('yellow');
                if (!prompt.includes('yellow')) corrections.push('yellow');
                applied = true;
            }
            else if (matchesWord(prompt, ['purple', 'purpel', 'pruple', 'purpl'])) {
                applyColorTheme('purple');
                if (!prompt.includes('purple')) corrections.push('purple');
                applied = true;
            }
            else if (matchesWord(prompt, ['pink', 'pnk', 'pinck'])) {
                applyColorTheme('pink');
                if (!prompt.includes('pink')) corrections.push('pink');
                applied = true;
            }
            else if (matchesWord(prompt, ['rainbow', 'rainbo', 'colorful', 'colours', 'colors'])) {
                applyColorTheme('rainbow');
                applied = true;
            }

            // Animation detection with typo handling
            if (matchesWord(prompt, ['spin', 'rotate', 'turn', 'spinn', 'rotat'])) {
                applyAnimation('spin');
                if (!prompt.includes('spin') && !prompt.includes('rotate')) corrections.push('spin');
                applied = true;
            }
            else if (matchesWord(prompt, ['dance', 'danc', 'dancing', 'party', 'boogie'])) {
                applyAnimation('dance');
                if (prompt.includes('danc') && !prompt.includes('dance')) corrections.push('dance');
                applied = true;
            }
            else if (matchesWord(prompt, ['bounce', 'jump', 'hop', 'bouncy'])) {
                applyAnimation('bounce');
                applied = true;
            }
            else if (matchesWord(prompt, ['shake', 'vibrat', 'shak', 'earthquake'])) {
                applyAnimation('shake');
                if (!prompt.includes('shake')) corrections.push('shake');
                applied = true;
            }
            else if (matchesWord(prompt, ['float', 'hover', 'fly', 'floaty'])) {
                applyAnimation('floating');
                applied = true;
            }
            else if (matchesWord(prompt, ['wobble', 'wiggle', 'woble', 'jiggle'])) {
                applyAnimation('wobble');
                if (!prompt.includes('wobble')) corrections.push('wobble');
                applied = true;
            }
            else if (matchesWord(prompt, ['pulse', 'beat', 'throb', 'heartbeat'])) {
                applyAnimation('pulse');
                applied = true;
            }
            else if (matchesWord(prompt, ['glitch', 'error', 'bug', 'corrupt'])) {
                applyAnimation('glitch');
                applied = true;
            }

            // Size effects
            if (matchesWord(prompt, ['big', 'large', 'huge', 'giant', 'massive', 'bigger'])) {
                applyEffect('giant');
                applied = true;
            }
            else if (matchesWord(prompt, ['small', 'tiny', 'mini', 'little', 'smaller'])) {
                applyEffect('tiny');
                applied = true;
            }

            // Special effects
            if (matchesWord(prompt, ['glow', 'neon', 'bright', 'shine', 'light'])) {
                applyEffect('neon-glow');
                applied = true;
            }
            else if (matchesWord(prompt, ['blur', 'blurry', 'unfocus', 'soft'])) {
                applyEffect('blur-effect');
                applied = true;
            }
            else if (matchesWord(prompt, ['hide', 'invisible', 'gone', 'disappear'])) {
                applyEffect('hidden');
                applied = true;
            }

            // Theme effects
            if (matchesWord(prompt, ['fire', 'flame', 'burn', 'hot', 'lava'])) {
                applyTheme('fire-mode');
                applied = true;
            }
            else if (matchesWord(prompt, ['ocean', 'water', 'sea', 'wave', 'aqua'])) {
                applyTheme('ocean-mode');
                applied = true;
            }
            else if (matchesWord(prompt, ['space', 'galaxy', 'stars', 'cosmic', 'universe'])) {
                applyTheme('space-mode');
                applied = true;
            }
            else if (matchesWord(prompt, ['night', 'dark', 'darkness', 'black'])) {
                applyTheme('night-mode');
                applied = true;
            }

            // Particle effects
            if (matchesWord(prompt, ['confetti', 'party', 'celebrate', 'celebration'])) {
                createConfetti();
                applied = true;
            }
            else if (matchesWord(prompt, ['hearts', 'love', 'romance', 'heart'])) {
                createHearts();
                applied = true;
            }

            // Emotion detection
            if (matchesWord(prompt, ['happy', 'joy', 'excited', 'good', 'great'])) {
                applyColorTheme('yellow');
                applyAnimation('bounce');
                createHearts();
                showResponse("😊 I can feel your happiness! Spreading joy with sunshine colors!", 'success');
                return;
            }
            else if (matchesWord(prompt, ['sad', 'down', 'unhappy', 'bad'])) {
                applyColorTheme('blue');
                showResponse("💙 I understand you might be feeling down. Here's a calming blue.", 'success');
                return;
            }

            // Reset commands
            if (matchesWord(prompt, ['reset', 'normal', 'clear', 'default', 'stop'])) {
                resetAll();
                showResponse("🔄 Everything reset to normal!", 'success');
                return;
            }

            // Generate response
            if (applied) {
                let responseText = "✨ Magic applied!";
                if (corrections.length > 0) {
                    responseText = `✅ Got it! I think you meant "${corrections[0]}" - effect applied!`;
                    showResponse(responseText, 'suggestion');
                } else {
                    showResponse(responseText, 'success');
                }
            } else {
                handleCreativeFallback(prompt);
            }
        }

        function matchesWord(text, wordList) {
            return wordList.some(word => text.includes(word));
        }

        function handleCreativeFallback(prompt) {
            // Creative responses for unrecognized input
            if (prompt.length > 20) {
                applyAnimation('pulse');
                showResponse("📝 Wow, that's a lot of text! Here's a pulsing effect!", 'success');
            } else if (prompt.length < 3) {
                applyEffect('tiny');
                showResponse("🤏 Short and sweet! Making things tiny to match!", 'success');
            } else if (prompt.includes('!')) {
                applyAnimation('dance');
                createConfetti();
                showResponse("❗ I love your enthusiasm! Let's celebrate!", 'success');
            } else if (prompt.includes('?')) {
                applyAnimation('wobble');
                showResponse("❓ I see you're curious! Here's a wobbly mystery effect!", 'success');
            } else {
                // Random effect for unknown input
                const randomEffects = ['spin', 'bounce', 'rainbow', 'glow'];
                const randomEffect = randomEffects[Math.floor(Math.random() * randomEffects.length)];
                
                if (randomEffect === 'rainbow') {
                    applyColorTheme('rainbow');
                } else if (randomEffect === 'glow') {
                    applyEffect('neon-glow');
                } else {
                    applyAnimation(randomEffect);
                }
                
                showResponse(`🎲 I don't recognize "${prompt}" but it sounds interesting! Here's something creative!`, 'suggestion');
            }
        }

        function applyColorTheme(color) {
            resetThemes();
            document.body.classList.add(`${color}-theme`);
        }

        function applyTheme(theme) {
            resetThemes();
            document.body.classList.add(theme);
        }

        function applyAnimation(animation) {
            const cards = document.querySelectorAll('.content-card');
            cards.forEach(card => {
                card.classList.remove('floating', 'spin', 'dance', 'bounce', 'wobble', 'pulse', 'glitch');
                card.classList.add(animation);
            });

            if (animation === 'shake') {
                document.querySelector('.container').classList.add('shake');
                setTimeout(() => {
                    document.querySelector('.container').classList.remove('shake');
                }, 500);
            }
        }

        function applyEffect(effect) {
            const cards = document.querySelectorAll('.content-card');
            const header = document.querySelector('.header');
            
            cards.forEach(card => {
                card.classList.remove('giant', 'tiny', 'hidden', 'neon-glow', 'blur-effect');
                card.classList.add(effect);
            });

            if (effect === 'neon-glow') {
                header.classList.add('neon-glow');
            }
        }

        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd'];
            
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }, i * 50);
            }
        }

        function createHearts() {
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.className = 'hearts';
                    heart.textContent = '💖';
                    heart.style.left = Math.random() * 100 + '%';
                    heart.style.fontSize = (Math.random() * 20 + 15) + 'px';
                    document.body.appendChild(heart);
                    
                    setTimeout(() => {
                        heart.remove();
                    }, 4000);
                }, i * 100);
            }
        }

        function resetThemes() {
            const body = document.body;
            body.classList.remove(
                'red-theme', 'blue-theme', 'green-theme', 'yellow-theme', 
                'purple-theme', 'pink-theme', 'rainbow', 'fire-mode', 
                'ocean-mode', 'space-mode', 'night-mode'
            );
        }

        function resetAll() {
            const body = document.body;
            const cards = document.querySelectorAll('.content-card');
            const header = document.querySelector('.header');
            
            // Reset all classes
            resetThemes();
            body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            
            cards.forEach(card => {
                card.className = 'content-card';
            });
            
            header.classList.remove('neon-glow');
            document.querySelector('.container').className = 'container';
            
            // Remove particles
            document.querySelectorAll('.confetti, .hearts').forEach(el => el.remove());
        }

        function showResponse(message, type = 'success') {
            const responseDiv = document.getElementById('responseMessage');
            responseDiv.textContent = message;
            responseDiv.className = `response-message ${type}`;
            responseDiv.style.display = 'block';
            responseDiv.classList.add('fade-in');
            
            setTimeout(() => {
                responseDiv.classList.remove('fade-in');
            }, 1000);
        }

        // Enter key support
        document.getElementById('promptInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                executePrompt();
            }
        });
    </script>

</body></html>